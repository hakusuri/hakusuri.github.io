<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/blog_icon_194621.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/blog_icon_194621-16x6.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":"enable","show_result":true,"style":"default"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"manual","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="运输层概述a、计算机网络体系结构中的物理层、数据链路层以及网络层它们共同解决了将主机通过异构网络互联起来所面临的问题，实现了主机到主机的通信。 b、在计算机网络中进行通信的真正实体是位于通信两端主机中的进程。 c、运输层的任务是如何为运行在不同主机上的应用进程提供直接的通信服务，运输层协议又称为端到端协议。 d、运输层向高层用户屏蔽了下面网络核心的细节(如网络拓扑、所采用的路由选择协议等)，它使应">
<meta property="og:type" content="article">
<meta property="og:title" content="运输层">
<meta property="og:url" content="http://example.com/2025/02/22/%E8%BF%90%E8%BE%93%E5%B1%82/index.html">
<meta property="og:site_name" content="HakusuriのBlog">
<meta property="og:description" content="运输层概述a、计算机网络体系结构中的物理层、数据链路层以及网络层它们共同解决了将主机通过异构网络互联起来所面临的问题，实现了主机到主机的通信。 b、在计算机网络中进行通信的真正实体是位于通信两端主机中的进程。 c、运输层的任务是如何为运行在不同主机上的应用进程提供直接的通信服务，运输层协议又称为端到端协议。 d、运输层向高层用户屏蔽了下面网络核心的细节(如网络拓扑、所采用的路由选择协议等)，它使应">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/images/QQ20250216-220744.png">
<meta property="og:image" content="http://example.com/images/QQ20250217-170901.png">
<meta property="og:image" content="http://example.com/images/QQ20250217-211150.png">
<meta property="og:image" content="http://example.com/images/QQ20250217-215126.png">
<meta property="og:image" content="http://example.com/images/QQ20250217-222619.png">
<meta property="article:published_time" content="2025-02-22T09:41:23.000Z">
<meta property="article:modified_time" content="2025-02-22T09:45:06.334Z">
<meta property="article:author" content="hakusuri">
<meta property="article:tag" content="计算机网络">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/images/QQ20250216-220744.png">

<link rel="canonical" href="http://example.com/2025/02/22/%E8%BF%90%E8%BE%93%E5%B1%82/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>运输层 | HakusuriのBlog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="HakusuriのBlog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">HakusuriのBlog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-resources">

    <a href="/resources/" rel="section"><i class="far fa-save fa-fw"></i>资源</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/02/22/%E8%BF%90%E8%BE%93%E5%B1%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="hakusuri">
      <meta itemprop="description" content="Hakusuri的个人生活">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HakusuriのBlog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          运输层
        </h1>

        <div class="post-meta">
	  
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-02-22 17:41:23 / 修改时间：17:45:06" itemprop="dateCreated datePublished" datetime="2025-02-22T17:41:23+08:00">2025-02-22</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Learning-Notes/" itemprop="url" rel="index"><span itemprop="name">Learning Notes</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>12k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>11 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a><center>运输层</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><pre><code>a、计算机网络体系结构中的物理层、数据链路层以及网络层它们共同解决了将主机通过异构网络互联起来所面临的问题，实现了主机到主机的通信。
b、在计算机网络中进行通信的真正实体是位于通信两端主机中的进程。
c、运输层的任务是如何为运行在不同主机上的应用进程提供直接的通信服务，运输层协议又称为端到端协议。
d、运输层向高层用户屏蔽了下面网络核心的细节(如网络拓扑、所采用的路由选择协议等)，它使应用进程看见的就好像是在两个运输层实体之间有一条端到端的逻辑通信信道。
e、根据应用需求的不同，因特网的运输层为应用层提供了两种不同的运输协议，即面向连接的TCP和无连接的UDP。
</code></pre>
<span id="more"></span>

<h2 id="运输层端口号、复用及分用的概念"><a href="#运输层端口号、复用及分用的概念" class="headerlink" title="运输层端口号、复用及分用的概念"></a>运输层端口号、复用及分用的概念</h2><h4 id="1、端口号："><a href="#1、端口号：" class="headerlink" title="1、端口号："></a>1、端口号：</h4><pre><code>a、运行在计算机上的进程使用进程标识符PID来标志。
b、因特网上的计算机并不是使用统一的操作系统，不同的操作系统(windows，Linux，MacOS)又使用不同格式的进程标识符。
c、为了使运行不同操作系统的计算机的应用进程之间能够进行网络通信，就必须使用统一的方法对TCP/IP体系的应用进程进行标识。
d、TCP/IP体系的运输层使用端口号来区分应用层的不同应用进程。
    (1)端口号使用16比特表示，取值范围0~65535:
        (a)熟知端口号:0~1023，IANA把这些端口号指派给了TCP/IP体系中最重要的一些应用协议，例如:FTP使用21/20，HTTP使用80，DNS使用53。
        (b)登记端口号:1024~49151，为没有熟知端口号的应用程序使用。使用这类端口号必须在IANA按照规定的手续登记，以防止重复。例如:Microsoft RDP微软远程桌面使用的端口是3389。
        (c)短暂端口号:49152~65535，留给客户进程选择暂时使用。当服务器进程收到客户进程的报文时，就知道了客户进程所使用的动态端口号。通信结束后，这个端口号可供其他客户进程以后使用。
    (2)端口号只具有本地意义，即端口号只是为了标识本计算机应用层中的各进程，在因特网中，不同计算机中的相同端口号是没有联系的。
</code></pre>
<h4 id="2、发送方的复用与接收方的分用："><a href="#2、发送方的复用与接收方的分用：" class="headerlink" title="2、发送方的复用与接收方的分用："></a>2、发送方的复用与接收方的分用：</h4><pre><code>a、如果某层的一个协议对应直接上层的多个协议/实体，则需要复用/分用。如运输层的UDP协议/TCP协议对应应用层多个端口、网络层的IP协议对应运输层的UDP协议/TCP协议。
b、发送端进行多路复用：从多个Socket接收数据，为每块数据封装头部信息，生成Segment，交给网络层。
c、接收端进行多路分用：传输层依据头部信息将收到的 Segment交给正确的Socket， 即不同的进程。
</code></pre>
<h4 id="3、TCP-IP-体系的应用层常用协议所使用的运输层熟知端口号："><a href="#3、TCP-IP-体系的应用层常用协议所使用的运输层熟知端口号：" class="headerlink" title="3、TCP&#x2F;IP 体系的应用层常用协议所使用的运输层熟知端口号："></a>3、TCP&#x2F;IP 体系的应用层常用协议所使用的运输层熟知端口号：</h4><p><img src="/images/QQ20250216-220744.png" alt="熟知端口号"></p>
<h2 id="UDP-和-TCP-的对比"><a href="#UDP-和-TCP-的对比" class="headerlink" title="UDP 和 TCP 的对比"></a>UDP 和 TCP 的对比</h2><h4 id="1、用户数据报协议-UDP-User-Datagram-Protocol"><a href="#1、用户数据报协议-UDP-User-Datagram-Protocol" class="headerlink" title="1、用户数据报协议 UDP(User Datagram Protocol)"></a>1、用户数据报协议 UDP(User Datagram Protocol)</h4><pre><code>a、使用UDP协议通信的双方可随时传输数据，为无连接的；
b、UDP支持单播，多播以及广播；
c、UDP是面向应用报文的，对上层交付的报文既不合并也不拆分，保留这些报文的边界，添加UDP首部后直接交付下层；
d、UDP向上层提供无连接不可靠传输服务，适用于IP电话、视频会议等实时应用；
e、UDP数据报仅由首部和数据载荷两部分组成，首部共8字节，分别为源端口、目的端口、长度、检验和4个字段，每个字段2字节。
</code></pre>
<h4 id="2、传输控制协议-TCP-Transmission-Control-Protocol"><a href="#2、传输控制协议-TCP-Transmission-Control-Protocol" class="headerlink" title="2、传输控制协议 TCP(Transmission Control Protocol)"></a>2、传输控制协议 TCP(Transmission Control Protocol)</h4><pre><code>a、使用TCP协议通信的双方，在数据传输前需使用“三报文握手”建立TCP连接，连接建立成功后可进行数据传输，数据传输结束后使用“四报文挥手”释放连接，该链接为逻辑连接，为面向连接的；
b、TCP仅支持单播；
c、TCP面向字节流，将上层交付的数据块视为比特流，根据发送策略提取一定数量的字节构建TCP报文发送，为实现可靠传输、流量控制、拥塞控制的基础；
d、TCP向上层提供面向连接的可靠传输服务，适用于要求可靠传输的应用如文件传输等；
e、TCP数据报仅由首部和数据载荷两部分组成，其首部最小长度为20字节，最大长度为60字节。
</code></pre>
<h2 id="TCP-的流量控制"><a href="#TCP-的流量控制" class="headerlink" title="TCP 的流量控制"></a>TCP 的流量控制</h2><pre><code>a、TCP（传输控制协议）的流量控制是一种机制，用于防止发送方向接收方发送过多数据，从而导致接收方的缓冲区溢出。TCP流量控制通过使用滑动窗口协议来实现，它允许接收方根据其可用缓冲区大小来调整发送方的发送速率。
b、TCP的分段和重排机制：TCP的分段重排机制，将超过MSS（Maximum segment size）的报文分割为n个单位为MSS的报文段。在发送时，会给每个报文段分配一个序列号（sequence），放在TCP头部，接受方每收到一个报文段会返回一个ack应答，ack的值表示期望收到的下一个报文段编号。其好处为 如果发生丢包, 那么不用将整个报文都重传, 只用重传丢失的那小段报文段。
c、TCP的流量控制主要通过以下两个机制实现：
    (1)滑动窗口（Sliding Window）：TCP使用滑动窗口来进行流量控制。接收方在TCP报文段的首部中通过&quot;接收窗口&quot;win字段告知自己的可接收数据量，即剩余的缓冲区大小。发送方根据接收方提供的窗口大小来决定发送数据的量，保证接收方能及时处理和接收数据。
        (a)发送方维护一个发送窗口，表示可以连续发送的数据量。
        (b)接收方维护一个接收窗口，表示还有多少空间可以接收数据。
        (c)发送方根据接收方提供的接收窗口大小来动态调整发送窗口的大小，以控制发送的数据量。
    (2)基于确认的流量控制：能确保发送方不会超出接收方的处理能力。接收方通过发送确认（ACK）报文来告知发送方已成功接收数据的字节数。发送方根据接收到的确认信息来调整发送数据的速率，避免发送过多的数据。
        (a)发送方发送数据后，等待接收方发送确认报文。
        (b)接收方收到数据后，发送确认报文，确认已成功接收数据。
        (c)发送方根据接收到的确认信息来调整发送窗口和发送速率，以控制数据的发送。
d、控制过程：TCP首部有个win字段, 即那个16位窗口大小, 能告诉对方自己接受缓存区当还能接收多少个字节的数据，这样就可以根据接收窗口的大小控制发送速率，达到流量控制的目的。
    (1)初始化窗口大小:
        在建立TCP连接时，双方协商并初始化流量控制的参数（TCP三次握手时, 接收方会跟据自身处理数据能力和接收缓冲区大小, 告诉发送方自己的接收窗口大小; 发送方据此设置自己的初始化发送窗口大小）。 其中包括窗口大小（通常是以字节为单位的接收缓冲区大小）和初始的拥塞窗口大小。
    (2)接收窗口通告:
        每次发送数据，接收方通过TCP报文段中的win&quot;窗口大小&quot;字段，通知发送方其当前可接收的字节数。这个窗口大小可以动态调整以反映接收方缓冲区的可用空间。
    (3)发送数据，确认等待:
        发送方维护一个发送窗口，它表示发送方可以发送的字节数。发送方根据接收方通告的窗口大小，不等一个一个地接收ACK，先把发送窗口内的数据都发送给接收方，但不会超出发送窗口限制，然后收到一个ACK移动一次，直到丢包一直等待收到丢包数据段ACK。
    (4)接收数据，动态调整窗口大小,发送ACK:
        (a)接收方接收到数据报段后，会返回一个ACK确认报文给接收方，ACK就是他期待收到的下一个数据报的序列号；发送方等待接收方对已发送数据的确认，随后看情况移动窗口。
        (b)接收方同时会根据自身的可用缓冲区空间和处理能力，动态调整窗口大小，并将新的窗口大小放在首部win字段中随ACK应答通告给发送方，这样，发送方根据win大小进行数据发送控制。
    (5)接收方窗口滑动: 发送方根据接收方的ACK报文和通告窗口大小，将窗口在发送缓冲区中向前滑动。ACK报文有以下几种情况:
        (a)如果报文中win=0，发送方停止发送，开启一个定时任务，每隔一段时间，就去询问接受方，直到 win 大于 0，才继续开始发送；
        (b)如果接收的ACK值等于接收窗口最左侧的报文段序号, 说明该报文段还没收到、接收方一直期待接收它，窗口停止滑动，直到超时重传或者接收到该报文段的ACK（ACK值为窗口右端下一个报文段序号）。
        (c)如果一直在发送请求某个报文段的确认ACK，并且超过三次，或者有报文段超时重传，发送方会假设网络发生拥塞，并采取相应的拥塞控制机制。
e、发送窗口=MIN[拥塞窗口，接收窗口]
</code></pre>
<h2 id="TCP-的拥塞控制"><a href="#TCP-的拥塞控制" class="headerlink" title="TCP 的拥塞控制"></a>TCP 的拥塞控制</h2><pre><code>a、在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络性能就要变坏这种情况就叫做拥塞(congestion)
b、在计算机网络中的链路容量(即带宽)、交换结点中的缓存和处理机等，都是网络的资源。
c、若出现拥塞而不进行控制，整个网络的吞吐量将随输入负荷的增大而下降
</code></pre>
<h4 id="1、吞吐量随负载的变化"><a href="#1、吞吐量随负载的变化" class="headerlink" title="1、吞吐量随负载的变化"></a>1、吞吐量随负载的变化</h4><p><img src="/images/QQ20250217-170901.png" alt="吞吐量随负载的变化"></p>
<pre><code>a、具有理想拥塞控制的网络，在吞吐量达到饱和之前，网络吞吐量应等于输入的负载，故吞吐量曲线是45°的斜线。但当输入负载超过某一限度时，吞吐量就不再增长而保持水平线。也就是吞吐量达到饱和，这就表明输入的负载中有一部分损失掉了。例如，输入到网络中的某些分组被某个节点丢弃了。虽然如此，网络的吞吐量仍然维持在其所能达到的最大值。
b、实际无拥塞控制下，当网络的吞吐量明显地小于理想的吞吐量时，网络就进入了轻度拥塞的状态。当输入负载到达某一数值时，网络的吞吐量反而随着负载的增大而减小，这时网络就进入了拥塞状态。当输入负载继续增大到某一数值时，网络的吞吐量就减小为0，此时网络就无法工作了，这就是所谓的死锁。
</code></pre>
<h4 id="2、慢开始-slow-start-和拥塞避免-congestion-avoidance-："><a href="#2、慢开始-slow-start-和拥塞避免-congestion-avoidance-：" class="headerlink" title="2、慢开始(slow-start)和拥塞避免(congestion avoidance)："></a>2、慢开始(slow-start)和拥塞避免(congestion avoidance)：</h4><pre><code>a、发送方维护一个叫做拥塞窗口cwnd的状态变量，其值取决于网络的拥塞程度，并且动态变化。
    (1)拥塞窗口cwnd的维护原则:只要网络没有出现拥塞，拥塞窗口就再增大一些;但只要网络出现拥塞，拥塞窗口就减少一些。
    (2)判断出现网络拥塞的依据:没有按时收到应当到达的确认报文(即发生超时重传).
b、发送方将拥塞窗口作为发送窗口swnd，即swnd=cwnd。
c、维护一个慢开始门限ssthresh状态变量:
    (1)当cwnd &lt; ssthresh时，使用慢开始算法;
    (2)当cwnd &gt; ssthresh时，停止使用慢开始算法而改用拥塞避免算法;
    (3)当cwnd = ssthresh时，既可使用慢开始算法，也可使用拥塞避免算法。
d、慢开始过程：
    慢开始是建立TCP连接后，采用的第一个调整发送速率的算法（或叫模式）。在这个阶段，cwnd通常被初始化为1MSS，这个值比较小，在这个时候，网络一般还有足够的富余，而慢开始的目的就是尽快找到上限。在慢开始阶段，发送方每接收到一个确认报文，就会将cwnd增加1MSS的大小，于是：
        初始cwnd=1MSS，所以可以发送一个TCP最大报文段，成功确认后，cwnd = 2MSS；
        此时可以发送两个TCP最大报文段，成功接收后，cwnd = 4 MSS；
        此时可以发送四个TCP最大报文段，成功接收后，cwnd = 8 MSS......
      由于TCP是一次性将窗口内的所有报文发出，所以所有报文都到达并被确认的时间，近似的等于一个RTT。所以在这个阶段，拥塞窗口cwnd的长度将在每个RTT后翻倍，也就是发送速率将以指数级别增长。在此期间，若cwnd增加到预设的ssthresh时，停止使用慢开始算法，转而使用避免拥塞算法。
e、避免拥塞过程：
    拥塞避免算法让拥塞窗口缓慢增长，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。这样拥塞窗口按线性规律缓慢增长。
f、在执行慢开始算法和拥塞避免算法的任意一个阶段，若有TCP报文的超时重传计时器超时，则判断网络可能出现拥塞。此时将ssthresh值更新为发生拥塞时cwnd值的一半;将cwnd值减少为1，并重新开始执行慢开始算法。
g、“慢开始”是指一开始向网络注入的报文段少，并不是指拥塞窗口cwnd增长速度慢;“拥塞避免”并非指完全能够避免拥塞，而是指在拥塞避免阶段将拥塞窗口控制为按线性规律增长，使网络比较不容易出现拥塞;
</code></pre>
<h4 id="3、快重传-fast-retransmit-和快恢复-fast-recovery"><a href="#3、快重传-fast-retransmit-和快恢复-fast-recovery" class="headerlink" title="3、快重传(fast retransmit)和快恢复(fast recovery)"></a>3、快重传(fast retransmit)和快恢复(fast recovery)</h4><pre><code>a、慢开始和拥塞避免算法是1988年提出的TCP拥塞控制算法(TCPTahoe版本)
b、1990年又增加了两个新的拥塞控制算法(改进TCP的性能)，这就是快重传和快恢复(TCP Reno版本):
    (1)有时，个别报文段会在网络中丢失，但实际上网络并未发生拥塞。这将导致发送方超时重传，并误认为网络发生了拥塞;
    (2)发送方把拥塞窗口cwnd又设置为最小值1，并错误地启动慢开始算法，因而降低了传输效率.
c、采用快重传算法可以让发送方尽早知道发生了个别报文段的丢失。
d、所谓快重传，就是使发送方尽快进行重传，而不是等超时重传计时器超时再重传：
    (1)要求接收方不要等待自己发送数据时才进行捎带确认，而是要立即发送确认;
    (2)即使收到了失序的报文段也要立即发出对已收到的报文段的重复确认。
    (3)发送方一旦收到3个连续的重复确认，就将相应的报文段立即重传，而不是等该报文段的超时重传计时器超时再重传。
    (4)对于个别丢失的报文段，发送方不会出现超时重传，也就不会误认为出现了拥塞(进而降低拥塞窗口cwnd为1)。使用快重传可以使整个网络的吞吐量提高约20%。
e、发送方一旦收到3个重复确认，就知道现在只是丢失了个别的报文段。于是不启动慢开始算法，而执行快恢复算法：
    (1)发送方将慢开始门限ssthresh值和拥塞窗口cwnd值调整为当前窗口的一半;开始执行拥塞避免算法。
    (2)也有的快恢复实现是把快恢复开始时的拥塞窗口cwnd值再增大一些，即等于新的ssthresh +3.
        (a)既然发送方收到3个重复的确认，就表明有3个数据报文段已经离开了网络;
        (b)这3个报文段不再消耗网络资源而是停留在接收方的接收缓存中;
        (c)可见现在网络中不是堆积了报文段而是减少了3个报文段。因此可以适当把拥塞窗口扩大些。
</code></pre>
<h2 id="TCP-超时重传时间的选择"><a href="#TCP-超时重传时间的选择" class="headerlink" title="TCP 超时重传时间的选择"></a>TCP 超时重传时间的选择</h2><pre><code>a、不能直接使用某次测量得到的RTT样本来计算超时重传时间RTO。
b、利用每次测量得到的RTT样本，计算加权平均往返时间RTTs(又称为平滑的往返时间)：
    (1)RTTs1= RTT1
    (2)新的RTTs=(1-α) x 旧的RTTs + α x 新的RTT样本
c、在上式中，0≤α&lt;1:
    (1)若 α 很接近于0，则新RTT样本对RTTs的影响不大;
    (2)若 α 很接近于1，则新RTT样本对RTTs的影响较大，
    (3)已成为建议标准的RFC6298推荐的α值为1/8，即0.125.
d、用这种方法得出的加权平均往返时间RTTS就比测量出的RTT值更加平滑。
e、显然，超时重传时间RTO应略大于加权平均往返时间RTTS。
f、RFC6298建议使用下式计算超时重传时间RTO:
    RTO=RTTs + 4 x RTTd
g、RTT偏差的加权平均RTTd:
    (1)RTTd1 = RTT1 / 2
    (2)新的RTTd = (1-B) x 旧的RTTd + B x | RTTs - 新的RTT样本 |
    (3)0≤B&lt;1
    (4)已成为建议标准的RFC6298推荐的B值为1/4，即0.25。
h、针对出现超时重传时无法测准往返时间RTT的问题，Karn提出了一个算法:在计算加权平均往返时间RTTS时，只要报文段重传了，就不采用其往返时间RTT样本。也就是出现重传时，不重新计算RTTS，进而超时重传时间RTO也不会重新计算。这又引起了新的问题。设想出现这样的情况:报文段的时延突然增大了很多，并且之后很长一段时间都会保持这种时延。因此在原来得出的重传时间内，不会收到确认报文段。于是就重传报文段。但根据Karn算法，不考虑重传的报文段的往返时间样本。这样，超时重传时间就无法更新。这会导致报文段反复被重传。因此，要对Karn算法进行修正。方法是:报文段每重传一次，就把超时重传时间RTO增大一些。典型的做法是将新RTO的值取为旧RTO值的2倍。
</code></pre>
<h2 id="TCP-可靠传输的实现"><a href="#TCP-可靠传输的实现" class="headerlink" title="TCP 可靠传输的实现"></a>TCP 可靠传输的实现</h2><h4 id="1、TCP-基于以字节为单位的滑动窗口来实现可靠传输"><a href="#1、TCP-基于以字节为单位的滑动窗口来实现可靠传输" class="headerlink" title="1、TCP 基于以字节为单位的滑动窗口来实现可靠传输"></a>1、TCP 基于以字节为单位的滑动窗口来实现可靠传输</h4><pre><code>a、发送方仅允许发送窗口内的数据字节；发送窗口后沿外是以发送并收到确认的数据字节序号，可以从发送缓存中删除；发送窗口前沿外为当前不允许发送的数据字节的序号。
b、后沿的移动情况：
    (1)不动：没有收到新的确认；
    (2)前移：收到了新的确认。
c、前沿移动的情况：
    (1)通常情况下不断前移；
    (2)不动：没有收到新的确认，对方通知的窗口大小也没有改变；收到新的确认但对方通知的窗口大小缩小，使前沿正好不动。
    (3)向后收缩：对方通知窗口缩小。TCP标准不建议，因发送方在收到通知之前很可能已发送了许多数据。
d、发送窗口状态的描述：使用三个指针P1，P2，P3分别指向相应的字节序号：
    (1)小于P1的是已发送并已收到确认的部分;
    (2)大于等于P3的是不允许发送的部分;
    (3)P3-P1=发送窗口的尺寸;
    (4)P2-P1=已发送但尚未收到确认的字节数;
    (5)P3-P2=允许发送但当前尚未发送的字节数(又称为可用窗口或有效窗口)。
e、接收方仅允许接收接收窗口内的数据字节，仅能将按序到达的数据交付上层；接收窗口前的为已发送过确认并已交付主机；窗口后的序号不允许接收数据。
</code></pre>
<h4 id="2、虽然发送方的发送窗口是根据接收方的接收窗口设置的，但在同一时刻，发送方的发送窗口并不总是和接收方的接收窗口一样大。"><a href="#2、虽然发送方的发送窗口是根据接收方的接收窗口设置的，但在同一时刻，发送方的发送窗口并不总是和接收方的接收窗口一样大。" class="headerlink" title="2、虽然发送方的发送窗口是根据接收方的接收窗口设置的，但在同一时刻，发送方的发送窗口并不总是和接收方的接收窗口一样大。"></a>2、虽然发送方的发送窗口是根据接收方的接收窗口设置的，但在同一时刻，发送方的发送窗口并不总是和接收方的接收窗口一样大。</h4><pre><code>a、网络传送窗口值需要经历一定的时间滞后，并且这个时间还是不确定的。
b、发送方还可能根据网络当时的拥塞情况适当减小自己的发送窗口尺寸。
</code></pre>
<h4 id="3、对于不按序到达的数据应如何处理，TCP-并无明确规定。"><a href="#3、对于不按序到达的数据应如何处理，TCP-并无明确规定。" class="headerlink" title="3、对于不按序到达的数据应如何处理，TCP 并无明确规定。"></a>3、对于不按序到达的数据应如何处理，TCP 并无明确规定。</h4><pre><code>a、如果接收方把不按序到达的数据一律丢弃，那么接收窗口的管理将会比较简单，但这样做对网络资源的利用不利因为发送方会重复传送较多的数据。
b、TCP通常对不按序到达的数据是先临时存放在接收窗口中，等到字节流中所缺少的字节收到后，再按序交付上层的应用进程。
</code></pre>
<h4 id="4、TCP-要求接收方必须有累积确认和捎带确认机制，这样可以减小传输开销。接收方可以在合适的时候发送确认，也可以在自己有数据要发送时把确认信息顺便捎带上。"><a href="#4、TCP-要求接收方必须有累积确认和捎带确认机制，这样可以减小传输开销。接收方可以在合适的时候发送确认，也可以在自己有数据要发送时把确认信息顺便捎带上。" class="headerlink" title="4、TCP 要求接收方必须有累积确认和捎带确认机制，这样可以减小传输开销。接收方可以在合适的时候发送确认，也可以在自己有数据要发送时把确认信息顺便捎带上。"></a>4、TCP 要求接收方必须有累积确认和捎带确认机制，这样可以减小传输开销。接收方可以在合适的时候发送确认，也可以在自己有数据要发送时把确认信息顺便捎带上。</h4><pre><code>a、接收方不应过分推迟发送确认，否则会导致发送方不必要的超时重传，这反而浪费了网络的资源。TCP标准规定，确认推迟的时间不应超过0.5秒。若收到一连串具有最大长度的报文段，则必须每隔一个报文段就发送一个确认[RFC 11221]。
b、捎带确认实际上并不经常发生，因为大多数应用程序很少同时在两个方向上发送数据。
</code></pre>
<h4 id="5、TCP-的通信是全双工通信。通信中的每一方都在发送和接收报文段。因此，每一方都有自己的发送窗口和接收窗口。在谈到这些窗口时，一定要弄清楚是哪一方的窗口。"><a href="#5、TCP-的通信是全双工通信。通信中的每一方都在发送和接收报文段。因此，每一方都有自己的发送窗口和接收窗口。在谈到这些窗口时，一定要弄清楚是哪一方的窗口。" class="headerlink" title="5、TCP 的通信是全双工通信。通信中的每一方都在发送和接收报文段。因此，每一方都有自己的发送窗口和接收窗口。在谈到这些窗口时，一定要弄清楚是哪一方的窗口。"></a>5、TCP 的通信是全双工通信。通信中的每一方都在发送和接收报文段。因此，每一方都有自己的发送窗口和接收窗口。在谈到这些窗口时，一定要弄清楚是哪一方的窗口。</h4><h2 id="TCP-的运输连接管理"><a href="#TCP-的运输连接管理" class="headerlink" title="TCP 的运输连接管理"></a>TCP 的运输连接管理</h2><pre><code>a、TCP是面向连接的协议，它基于运输连接来传送TCP报文段。
b、TCP运输连接的建立和释放是每一次面向连接的通信中必不可少的过程。
c、TCP运输连接有以下三个阶段：
    (1)建立TCP连接；
    (2)数据传送；
    (3)释放TCP连接。
d、TCP的运输连接管理就是使运输连接的建立和释放都能正常地进行。
</code></pre>
<h4 id="1、TCP-的连接建立："><a href="#1、TCP-的连接建立：" class="headerlink" title="1、TCP 的连接建立："></a>1、TCP 的连接建立：</h4><pre><code>a、TCP的连接建立要解决以下三个问题：
    (1)使TCP双方能够确知对方的存在；
    (2)使TCP双方能够协商一些参数（如最大窗口值、是否使用窗口扩大选项和时间戳选项以及服务质量等）；
    (3)使TCP双方能够对运输实体资源（如缓存大小、连接表中的项目等）进行分配。
b、连接建立过程：
    (1)最开始的时候客户端和服务器都是处于CLOSED关闭状态。主动打开连接的为客户端，被动打开连接的是服务器。
    (2)TCP服务器进程先创建传输控制块TCB，时刻准备接受客户进程的连接请求，此时服务器就进入了 LISTEN 监听状态。
    (3)第一次握手：TCP客户进程也是先创建传输控制块TCB，然后向服务器发出连接请求报文，这是报文首部中的同部位SYN=1，同时选择一个初始序列号 seq=x ，此时，TCP客户端进程进入了 SYN-SENT 同步已发送状态。
    (4)第二次握手：TCP服务器收到请求报文后，如果同意连接，则会向客户端发出确认报文。确认报文中应该 ACK=1，SYN=1，确认号是ack=x+1，同时也要为自己初始化一个序列号 seq=y，此时，TCP服务器进程进入了 SYN-RCVD 同步收到状态；
    (5)第三次握手：TCP客户端收到确认后，还要向服务器给出确认。确认报文的ACK=1，ack=y+1，自己的序列号seq=x+1，此时，TCP连接建立，客户端进入ESTABLISHED已建立连接状态触发三次握手。
</code></pre>
<p><img src="/images/QQ20250217-211150.png" alt="三次握手"></p>
<pre><code>c、三次握手的目的：
    第一次握手： 客户端向服务器端发送报文证明客户端的发送能力正常。
    第二次握手：服务器端接收到报文并向客户端发送报文证明服务器端的接收能力、发送能力正常。
    第三次握手：客户端向服务器发送报文证明客户端的接收能力正常。
d、若采用两次握手产生的错误情况：客户端向服务器端发送的请求报文由于网络等原因滞留，未能发送到服务器端，此时连接请求报文失效，客户端会再次向服务器端发送请求报文，之后与服务器端建立连接，当连接释放后，由于网络通畅了，第一次客户端发送的请求报文又突然到达了服务器端，这条请求报文本该失效了，但此时服务器端误认为客户端又发送了一次连接请求，两次握手建立好连接，此时客户端忽略服务器端发来的确认，也不发送数据，造成不必要的错误和网络资源的浪费。如果采用三次握手的话，就算那条失效的报文发送到服务器端，服务器端确认并向客户端发送报文，但此时客户端不会发出确认，由于客户端没有确认，由于服务器端没有接收到确认，就会知道客户端没有请求连接。
e、注意：
    （1）TCP的标准规定，SYN=1的报文段不能携带数据，但要消耗掉一个序号。
    （2）TCP的标准规定，普通的确认报文段如果不携带数据，则不消耗序号。
</code></pre>
<h4 id="2、TCP-连接的释放："><a href="#2、TCP-连接的释放：" class="headerlink" title="2、TCP 连接的释放："></a>2、TCP 连接的释放：</h4><pre><code>a、释放的过程：
    (1)数据传输完毕后，双方都可释放连接。最开始的时候，客户端和服务器都是处于ESTABLISHED状态，然后客户端主动关闭，服务器被动关闭。
    (2)第一次挥手：客户端发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，ACK=1，其序列号为seq=u(等于前面已经传送过来的数据的最后一个字节的序号加1)，ack=v，v的值为客户端收到的上一个数据报文序号+1。此时，客户端进入FIN-WAIT-1(终止等待1)状态。
    (3)第二次挥手：服务器端接收到连接释放报文后，发出TCP普通确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT关闭等待状态，客户端对服务器的连接已断开，仅剩下服务器对客户端的单向连接，客户端已没有数据要发送，服务器还可向客户端发送数据。
    (4)第三次挥手：客户端接收到服务器端的确认请求后，客户端就会进入FIN-WAIT-2(终止等待2)状态，等待服务器发送连接释放报文，服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ACK=1，seq=w，w为服务端上次发送数据报文的序号+1，ack仍为u+1，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。
    (5)第四次挥手：客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，这是因为TCP客户进程之前发送的TCP连接释放报文段虽然不携带数据，但要消耗一个序号。此时，客户端就进入了TIME-WAIT(时间等待)状态，但此时TCP连接还未终止，必须要经过2MSL后（最长报文寿命），当客户端撤销相应的TCB后，客
    户端才会进入CLOSED关闭状态，服务器端接收到确认报文后，会立即进入CLOSED关闭状态，到这里TCP连接就断开了，四次挥手完成。
b、MSL(MaximumSegmentLifetime)意思是最长报文段寿命，RFC793建议为2分钟。
</code></pre>
<p><img src="/images/QQ20250217-215126.png" alt="四次挥手"></p>
<pre><code>c、客户端要等待2MSL的原因：
    主要原因是为了保证客户端第四次挥手发送的ACK报文能到到服务器，因为这个ACK报文可能丢失，导致服务器超时重传，而若此时客户端已关闭，则导致服务器对客户端的TCP连接无法关闭，消耗服务器资源；并且2MSL是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃，这样新的连接中不会出现旧连接的请求报文。
d、服务器如何发现客户端故障：
    (1)TCP服务器进程每收到一次TCP客户进程的数据，就重新设置并启动保活计时器（2小时定时）。
    (2)若保活计时器定时周期内未收到TCP客户进程发来的数据，则当保活计时器到时后，TCP服务器进程就向TCP客户进程发送一个探测报文段，以后则每隔75秒钟发送一次。若一连发送10个探测报文段后仍无TCP客户进程的响应，TCP服务器进程就认为TCP客户进程所在主机出了故障，接着就关闭这个连接。
</code></pre>
<h2 id="TCP-报文首部格式"><a href="#TCP-报文首部格式" class="headerlink" title="TCP 报文首部格式"></a>TCP 报文首部格式</h2><pre><code>a、为了实现可靠传输，TCP采用了面向字节流的方式。
b、但TCP在发送数据时，是从发送缓存取出一部分或全部字节并给其添加一个首部使之成为TCP报文段后进行发送。
    (1)一个TCP报文段由首部和数据载荷两部分构成；
    (2)TCP的全部功能都体现在它首部中各字段的作用。
</code></pre>
<h4 id="首部格式"><a href="#首部格式" class="headerlink" title="首部格式"></a>首部格式</h4><p><img src="/images/QQ20250217-222619.png" alt="首部格式"></p>
<pre><code>a、TCP报文首部以32bit即4字节为单位，前20字节为固定首部，最大可有40字节的扩展，即最小20字节、最大60字节。
b、源端口字段：占16比特，写入源端口号，用来标识发送该TCP报文段的应用进程。
c、目的端口字段：占16比特，写入目的端口号，用来标识接收该TCP报文段的应用进程。
d、序号字段、确认号字段、确认标志位ACK字段：与TCP实现可靠传输相关。
    (1)序号字段：占32比特，取值范围[0,2^32-1]，序号增加到最后一个后，下一个序号就又回到0。指出本TCP报文段数据载荷的第一个字节的序号，而不是其内容。
    (2)确认号字段：占32比特，取值范围[0,2^32-1]，确认号增加到最后一个后，下一个确认号就又回到0。指出期望收到对方下一个TCP报文段的数据载荷的第一个字节的序号，同时也是对之前收到的所有数据的确认即对对方序号字段的确认。若确认号=n，则表明到序号n-1为止的所有数据都已正确接收，期望接收序号为n的数据。
    (3)确认标志位ACK字段：取值为1时确认号字段才有效；取值为0时确认号字段无效。TCP规定，在连接建立后所有传送的TCP报文段都必须把ACK置1。
e、数据偏移字段：占4比特，并以4字节为单位。用来指出TCP报文段的数据载荷部分的起始处距离TCP报文段的起始处有多远。这个字段实际上是指出了TCP报文段的首部长度。首部固定长度为20字节，因此数据偏移字段的最小值为(0101)2；首部最大长度为60字节，因此数据偏移字段的最大值为(1111)2。
f、保留字段：占6比特，保留为今后使用，但目前应置为0。
g、窗口字段：占16比特，以字节为单位。指出发送本报文段的一方的接收窗口。窗口值作为接收方让发送方设置其发送窗口的依据。这是以接收方的接收能力来控制发送方的发送能力，称为流量控制。
h、校验和字段：占16比特，检查范围包括TCP报文段的首部和数据载荷两部分。在计算校验和时，要在TCP报文段的前面加上12字节的伪首部。
i、同步标志位SYN字段：在TCP连接建立时用来同步序号。报文首部中该字段被置1表明该报文为一个TCP连接请求报文段。
j、终止标志位FIN字段：用来释放TCP连接。报文首部中该字段被置1表明该报文为一个TCP连接释放报文段。
k、复位标志位RST字段：用来复位TCP连接。当RST=1时，表明TCP连接出现了异常，必须释放连接，然后再重新建立连接。RST置1还用来拒绝一个非法的报文段或拒绝打开一个TCP连接。
l、推送标志位PSH字段：接收方的TCP收到该标志位为1的报文段会尽快上交应用进程，而不必等到接收缓存都填满后再向上交付。
m、紧急标志位URG字段、紧急指针字段：用来实现紧急操作。当发送方有紧急数据时，可将紧急数据插队到发送缓存的最前面，并立刻封装到一个TCP报文段中进行发送。紧急指针会指出本报文段数据载荷部分包含了多长的紧急数据，紧急数据之后是普通数据。
    (1)紧急标志位URG字段：取值为1时紧急指针字段有效；取值为0时紧急指针字段无效。
    (2)紧急指针：占16比特，以字节为单位，用来指明紧急数据的长度。
n、选项字段(长度可变)：增加选项可以增加TCP报文的功能
    (1)最大报文段长度MSS选项：指出TCP报文段数据载荷部分的最大长度。
    (2)窗口扩大选项：为了扩大窗口（提高吞吐率）。
    (3)时间戳选项：
        (a)用来计算往返时间RTT。
        (b)用于处理序号超范围的情况，又称为防止序号绕回PAWS。
    (4)选择确认选项：用来实现选择确认功能。
o、填充字段：由于选项的长度可变，因此使用填充来确保报文段首部能被4整除（因为数据偏移字段，也就是首部长度字段，是以 4 字节为单位的）。
</code></pre>

    </div>

    
    
    

 
   <div>
     <div>
    
        <div style="text-align:center;color: #ccc;font-size:24px;">-------------本文结束<i class="far fa-power-off"></i>感谢您的阅读-------------</div>
    
</div>
   </div>
 
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>hakusuri
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://example.com/2025/02/22/%E8%BF%90%E8%BE%93%E5%B1%82/" title="运输层">http://example.com/2025/02/22/运输层/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag"># 计算机网络</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2025/02/22/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/" rel="prev" title="数据链路层">
      <i class="fa fa-chevron-left"></i> 数据链路层
    </a></div>
      <div class="post-nav-item">
    <a href="/2025/02/22/%E7%BD%91%E7%BB%9C%E5%B1%82/" rel="next" title="网络层">
      网络层 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%90%E8%BE%93%E5%B1%82"><span class="nav-number">1.</span> <span class="nav-text">运输层</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="nav-number">1.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%90%E8%BE%93%E5%B1%82%E7%AB%AF%E5%8F%A3%E5%8F%B7%E3%80%81%E5%A4%8D%E7%94%A8%E5%8F%8A%E5%88%86%E7%94%A8%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-number">1.2.</span> <span class="nav-text">运输层端口号、复用及分用的概念</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E7%AB%AF%E5%8F%A3%E5%8F%B7%EF%BC%9A"><span class="nav-number">1.2.0.1.</span> <span class="nav-text">1、端口号：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E5%8F%91%E9%80%81%E6%96%B9%E7%9A%84%E5%A4%8D%E7%94%A8%E4%B8%8E%E6%8E%A5%E6%94%B6%E6%96%B9%E7%9A%84%E5%88%86%E7%94%A8%EF%BC%9A"><span class="nav-number">1.2.0.2.</span> <span class="nav-text">2、发送方的复用与接收方的分用：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81TCP-IP-%E4%BD%93%E7%B3%BB%E7%9A%84%E5%BA%94%E7%94%A8%E5%B1%82%E5%B8%B8%E7%94%A8%E5%8D%8F%E8%AE%AE%E6%89%80%E4%BD%BF%E7%94%A8%E7%9A%84%E8%BF%90%E8%BE%93%E5%B1%82%E7%86%9F%E7%9F%A5%E7%AB%AF%E5%8F%A3%E5%8F%B7%EF%BC%9A"><span class="nav-number">1.2.0.3.</span> <span class="nav-text">3、TCP&#x2F;IP 体系的应用层常用协议所使用的运输层熟知端口号：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#UDP-%E5%92%8C-TCP-%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="nav-number">1.3.</span> <span class="nav-text">UDP 和 TCP 的对比</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%8D%8F%E8%AE%AE-UDP-User-Datagram-Protocol"><span class="nav-number">1.3.0.1.</span> <span class="nav-text">1、用户数据报协议 UDP(User Datagram Protocol)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE-TCP-Transmission-Control-Protocol"><span class="nav-number">1.3.0.2.</span> <span class="nav-text">2、传输控制协议 TCP(Transmission Control Protocol)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP-%E7%9A%84%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="nav-number">1.4.</span> <span class="nav-text">TCP 的流量控制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP-%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="nav-number">1.5.</span> <span class="nav-text">TCP 的拥塞控制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E5%90%9E%E5%90%90%E9%87%8F%E9%9A%8F%E8%B4%9F%E8%BD%BD%E7%9A%84%E5%8F%98%E5%8C%96"><span class="nav-number">1.5.0.1.</span> <span class="nav-text">1、吞吐量随负载的变化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E6%85%A2%E5%BC%80%E5%A7%8B-slow-start-%E5%92%8C%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D-congestion-avoidance-%EF%BC%9A"><span class="nav-number">1.5.0.2.</span> <span class="nav-text">2、慢开始(slow-start)和拥塞避免(congestion avoidance)：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E5%BF%AB%E9%87%8D%E4%BC%A0-fast-retransmit-%E5%92%8C%E5%BF%AB%E6%81%A2%E5%A4%8D-fast-recovery"><span class="nav-number">1.5.0.3.</span> <span class="nav-text">3、快重传(fast retransmit)和快恢复(fast recovery)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP-%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0%E6%97%B6%E9%97%B4%E7%9A%84%E9%80%89%E6%8B%A9"><span class="nav-number">1.6.</span> <span class="nav-text">TCP 超时重传时间的选择</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP-%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.7.</span> <span class="nav-text">TCP 可靠传输的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81TCP-%E5%9F%BA%E4%BA%8E%E4%BB%A5%E5%AD%97%E8%8A%82%E4%B8%BA%E5%8D%95%E4%BD%8D%E7%9A%84%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9D%A5%E5%AE%9E%E7%8E%B0%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93"><span class="nav-number">1.7.0.1.</span> <span class="nav-text">1、TCP 基于以字节为单位的滑动窗口来实现可靠传输</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E8%99%BD%E7%84%B6%E5%8F%91%E9%80%81%E6%96%B9%E7%9A%84%E5%8F%91%E9%80%81%E7%AA%97%E5%8F%A3%E6%98%AF%E6%A0%B9%E6%8D%AE%E6%8E%A5%E6%94%B6%E6%96%B9%E7%9A%84%E6%8E%A5%E6%94%B6%E7%AA%97%E5%8F%A3%E8%AE%BE%E7%BD%AE%E7%9A%84%EF%BC%8C%E4%BD%86%E5%9C%A8%E5%90%8C%E4%B8%80%E6%97%B6%E5%88%BB%EF%BC%8C%E5%8F%91%E9%80%81%E6%96%B9%E7%9A%84%E5%8F%91%E9%80%81%E7%AA%97%E5%8F%A3%E5%B9%B6%E4%B8%8D%E6%80%BB%E6%98%AF%E5%92%8C%E6%8E%A5%E6%94%B6%E6%96%B9%E7%9A%84%E6%8E%A5%E6%94%B6%E7%AA%97%E5%8F%A3%E4%B8%80%E6%A0%B7%E5%A4%A7%E3%80%82"><span class="nav-number">1.7.0.2.</span> <span class="nav-text">2、虽然发送方的发送窗口是根据接收方的接收窗口设置的，但在同一时刻，发送方的发送窗口并不总是和接收方的接收窗口一样大。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E5%AF%B9%E4%BA%8E%E4%B8%8D%E6%8C%89%E5%BA%8F%E5%88%B0%E8%BE%BE%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%94%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%EF%BC%8CTCP-%E5%B9%B6%E6%97%A0%E6%98%8E%E7%A1%AE%E8%A7%84%E5%AE%9A%E3%80%82"><span class="nav-number">1.7.0.3.</span> <span class="nav-text">3、对于不按序到达的数据应如何处理，TCP 并无明确规定。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81TCP-%E8%A6%81%E6%B1%82%E6%8E%A5%E6%94%B6%E6%96%B9%E5%BF%85%E9%A1%BB%E6%9C%89%E7%B4%AF%E7%A7%AF%E7%A1%AE%E8%AE%A4%E5%92%8C%E6%8D%8E%E5%B8%A6%E7%A1%AE%E8%AE%A4%E6%9C%BA%E5%88%B6%EF%BC%8C%E8%BF%99%E6%A0%B7%E5%8F%AF%E4%BB%A5%E5%87%8F%E5%B0%8F%E4%BC%A0%E8%BE%93%E5%BC%80%E9%94%80%E3%80%82%E6%8E%A5%E6%94%B6%E6%96%B9%E5%8F%AF%E4%BB%A5%E5%9C%A8%E5%90%88%E9%80%82%E7%9A%84%E6%97%B6%E5%80%99%E5%8F%91%E9%80%81%E7%A1%AE%E8%AE%A4%EF%BC%8C%E4%B9%9F%E5%8F%AF%E4%BB%A5%E5%9C%A8%E8%87%AA%E5%B7%B1%E6%9C%89%E6%95%B0%E6%8D%AE%E8%A6%81%E5%8F%91%E9%80%81%E6%97%B6%E6%8A%8A%E7%A1%AE%E8%AE%A4%E4%BF%A1%E6%81%AF%E9%A1%BA%E4%BE%BF%E6%8D%8E%E5%B8%A6%E4%B8%8A%E3%80%82"><span class="nav-number">1.7.0.4.</span> <span class="nav-text">4、TCP 要求接收方必须有累积确认和捎带确认机制，这样可以减小传输开销。接收方可以在合适的时候发送确认，也可以在自己有数据要发送时把确认信息顺便捎带上。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5%E3%80%81TCP-%E7%9A%84%E9%80%9A%E4%BF%A1%E6%98%AF%E5%85%A8%E5%8F%8C%E5%B7%A5%E9%80%9A%E4%BF%A1%E3%80%82%E9%80%9A%E4%BF%A1%E4%B8%AD%E7%9A%84%E6%AF%8F%E4%B8%80%E6%96%B9%E9%83%BD%E5%9C%A8%E5%8F%91%E9%80%81%E5%92%8C%E6%8E%A5%E6%94%B6%E6%8A%A5%E6%96%87%E6%AE%B5%E3%80%82%E5%9B%A0%E6%AD%A4%EF%BC%8C%E6%AF%8F%E4%B8%80%E6%96%B9%E9%83%BD%E6%9C%89%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8F%91%E9%80%81%E7%AA%97%E5%8F%A3%E5%92%8C%E6%8E%A5%E6%94%B6%E7%AA%97%E5%8F%A3%E3%80%82%E5%9C%A8%E8%B0%88%E5%88%B0%E8%BF%99%E4%BA%9B%E7%AA%97%E5%8F%A3%E6%97%B6%EF%BC%8C%E4%B8%80%E5%AE%9A%E8%A6%81%E5%BC%84%E6%B8%85%E6%A5%9A%E6%98%AF%E5%93%AA%E4%B8%80%E6%96%B9%E7%9A%84%E7%AA%97%E5%8F%A3%E3%80%82"><span class="nav-number">1.7.0.5.</span> <span class="nav-text">5、TCP 的通信是全双工通信。通信中的每一方都在发送和接收报文段。因此，每一方都有自己的发送窗口和接收窗口。在谈到这些窗口时，一定要弄清楚是哪一方的窗口。</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP-%E7%9A%84%E8%BF%90%E8%BE%93%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86"><span class="nav-number">1.8.</span> <span class="nav-text">TCP 的运输连接管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81TCP-%E7%9A%84%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B%EF%BC%9A"><span class="nav-number">1.8.0.1.</span> <span class="nav-text">1、TCP 的连接建立：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81TCP-%E8%BF%9E%E6%8E%A5%E7%9A%84%E9%87%8A%E6%94%BE%EF%BC%9A"><span class="nav-number">1.8.0.2.</span> <span class="nav-text">2、TCP 连接的释放：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP-%E6%8A%A5%E6%96%87%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F"><span class="nav-number">1.9.</span> <span class="nav-text">TCP 报文首部格式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F"><span class="nav-number">1.9.0.1.</span> <span class="nav-text">首部格式</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="hakusuri"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">hakusuri</p>
  <div class="site-description" itemprop="description">Hakusuri的个人生活</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">8</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/hakusuri" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;hakusuri" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://space.bilibili.com/244305717?spm_id_from=333.1007.0.0" title="bilibili → https:&#x2F;&#x2F;space.bilibili.com&#x2F;244305717?spm_id_from&#x3D;333.1007.0.0" rel="noopener" target="_blank"><i class="far fa-tv fa-fw"></i>bilibili</a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>
    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">hakusuri</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">69k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">1:02</span>
</div>
  <div class="powered-by">
<!--由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
-->
  </div>


    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">总访客数<span id="busuanzi_value_site_uv"></span>人</span>
    <span class="post-meta-divider">|</span>
<!-- 不蒜子计数初始值纠正 -->
<script>
$(document).ready(function() {

    var int = setInterval(fixCount, 50);  // 50ms周期检测函数
    var countOffset = 20000;  // 初始化首次数据

    function fixCount() {            
       if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset); 
            clearInterval(int);
        }                  
        if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset); // 加上初始数据 
            clearInterval(int); // 停止检测
        }  
    }
       	
});
</script> 


<!-- 网站运行时间的设置 -->
<span id="timeDate">载入天数...</span>
<span id="times">载入时分秒...</span>
<script>
    var now = new Date();
    function createtime() {
        var grt= new Date("02/02/2025 22:00:00"); //此处修改你的建站时间或者网站上线时间
        now.setTime(now.getTime()+250);
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
        document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 ";
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒.";
    }
setInterval("createtime()",250);
</script>
        
<div class="busuanzi-count">
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  




  
<script src="/js/local-search.js"></script>













    <div id="pjax">
  

  

  

    </div>

<!--音乐-->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css">
  <script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/meting@1.2/dist/Meting.min.js"></script>
  <div id="player" class="aplayer aplayer-withlist aplayer-fixed" data-id="7545855392" data-server="tencent" data-type="playlist" data-order="random" data-fixed="true" data-listfolded="true" data-theme="#2D8CF0"></div>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/assets/haru01.model.json"},"display":{"position":"right","width":200,"height":400},"mobile":{"show":true}});</script></body>
</html>
